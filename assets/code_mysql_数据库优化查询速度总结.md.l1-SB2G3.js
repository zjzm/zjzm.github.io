import{_ as s,c as i,o as a,a4 as l}from"./chunks/framework.qL1yNBZ5.js";const t="/mysql/image-20240817142657033.png",n="/mysql/image-20240817143143775.png",e="/mysql/image-20240817143418962.png",p="/mysql/image-20240817143516116.png",h="/mysql/image-20240817143550782.png",u=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"code/mysql/数据库优化查询速度总结.md","filePath":"code/mysql/数据库优化查询速度总结.md"}'),k={name:"code/mysql/数据库优化查询速度总结.md"},r=l(`<h2 id="常用的sql查询方法" tabindex="-1">常用的sql查询方法 <a class="header-anchor" href="#常用的sql查询方法" aria-label="Permalink to &quot;常用的sql查询方法&quot;">​</a></h2><h3 id="_1、查看数据表占用的空间大小" tabindex="-1">1、查看数据表占用的空间大小 <a class="header-anchor" href="#_1、查看数据表占用的空间大小" aria-label="Permalink to &quot;1、查看数据表占用的空间大小&quot;">​</a></h3><ul><li>TABLE_NAME：表名</li><li>TABLE_ROWS：总行数</li><li>DATA_LENGTH：表数据大小</li><li>INDEX_LENGTH：索引大小</li></ul><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">SELECT</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    TABLE_NAME,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    TABLE_ROWS,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    DATA_LENGTH,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    INDEX_LENGTH,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    (DATA_LENGTH </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> INDEX_LENGTH) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">AS</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> total_size</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">FROM</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> </span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    information_schema</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">tables</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">WHERE</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    TABLE_SCHEMA </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;库名&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> #数据库名</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">AND</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> TABLE_NAME </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;表名&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;#数据表名</span></span></code></pre></div><h3 id="_2、更新索引的统计信息" tabindex="-1">2、更新索引的统计信息 <a class="header-anchor" href="#_2、更新索引的统计信息" aria-label="Permalink to &quot;2、更新索引的统计信息&quot;">​</a></h3><p>MySQL 会对指定表的索引进行分析，计算索引的分布情况，以便更好地估计查询的成本和选择合适的查询策略</p><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">ANALYZE </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">TABLE</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 表名;</span></span></code></pre></div><h3 id="_3、explain-sql-分析查询执行计划" tabindex="-1">3、EXPLAIN + SQL 分析查询执行计划 <a class="header-anchor" href="#_3、explain-sql-分析查询执行计划" aria-label="Permalink to &quot;3、EXPLAIN + SQL  分析查询执行计划&quot;">​</a></h3><ul><li><p>id：每个 SELECT 语句的 ID，用于标识查询块。</p></li><li><p>select_type：查询的类型，例如 SIMPLE（简单查询）、PRIMARY（主查询）、UNION 等。</p></li><li><p>table：涉及到的表名。</p></li><li><p>type：访问类型，例如 ALL（全表扫描）、index（索引扫描）、range（范围扫描）、ref（使用索引查找单行）等。</p></li><li><p>possible_keys：可能使用的索引。</p></li><li><p>key：实际使用的索引。</p></li><li><p>key_len：使用的索引长度。</p></li><li><p>ref：使用的键或常量。</p></li><li><p>rows：MySQL 预计需要检查的行数。</p></li><li><p>Extra：额外信息，例如 Using where（使用 WHERE 子句过滤结果）、Using index（使用覆盖索引）等</p></li></ul><h2 id="数据库优化" tabindex="-1">数据库优化 <a class="header-anchor" href="#数据库优化" aria-label="Permalink to &quot;数据库优化&quot;">​</a></h2><p><strong>在对MySQL查询进行优化时需要考虑多个方面，包括索引的选择、查询条件的优化以及查询计划的分析</strong></p><ol><li><strong>索引设计</strong> 当查询涉及多个条件时，考虑创建包含所有相关字段的复合索引。 复合索引的字段顺序应根据查询条件的重要性来确定，优先级高的字段放在前面。 对于经常作为查询条件出现的单个字段，考虑创建单字段索引。</li></ol><p>单字段索引适用于数据量较小的情况，可以快速过滤数据。</p><ol start="2"><li><p><strong>查询条件优化</strong> 使用合适的条件 尽量使用等值条件，避免使用 LIKE 开头的模糊匹配 会导致全表扫描。 避免在索引字段上使用函数 对于 NULL 值的判断，使用 IS NULL 或 IS NOT NULL，而不是 = NULL 或 &lt;&gt; NULL。</p></li><li><p><strong>查询计划分析</strong> 使用 EXPLAIN 命令来查看查询计划，了解 MySQL 如何执行查询。 观察 EXPLAIN 输出中的 key 列，确认是否使用了预期的索引。 关注 type、possible_keys、key、rows 和 Extra 列，这些信息可以帮助识别查询中的瓶颈。 <strong>如果 Extra 列中有 Using temporary 或 Using filesort，说明查询可能需要优化</strong></p></li></ol><p><img src="`+t+'" alt="image-20240817142657033"></p><ol start="4"><li><strong>空间占用</strong> 测试结果数据表一条复合索引大约占用3M左右 一般来说不需要考虑索引的空间占用 、除非是创建了特别多不同索引的情况下（不过对空间的占用可以忽略不及，牺牲少量空间换时间何乐而不为）</li></ol><h2 id="建立索引" tabindex="-1">建立索引 <a class="header-anchor" href="#建立索引" aria-label="Permalink to &quot;建立索引&quot;">​</a></h2><p><strong>MySQL 优化器会根据查询条件、表的统计数据和索引的统计信息来决定使用哪个索引</strong></p><p><strong>当数据表中数据量较多/较少时mysql优化器会优先选择不同得索引来执行查询</strong></p><p><strong>数据量较多时</strong>：mysql优化器倾向于选择能够有效过滤数据的索引来执行查询、复合索引通常更适合这种场景，因为它们可以同时满足多个查询条件，从而减少需要扫描的数据量 <strong>数据量较少时</strong>：当数据量较少时，即使是全表扫描也可能比使用索引更快、mysql优化器会根据表的统计数据来决定是使用索引还是全表扫描</p><p>1、<strong>如果某些字段在查询中总是出现并且这些字段可以有效地过滤数据 则建议将固定字段建立复合索引 提交查询效率</strong></p><p>例如：SELECT * FROM 表名 WHERE <code>trade_mode</code> = &#39;9610&#39; AND <code>ucode</code> = &#39;cvy17&#39;; 每次查询时该值都存在，就可以给这两个字段建立复合索引提高查询效率</p><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">ALTER</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> TABLE</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 表名 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">ADD</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> INDEX</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> `idx1`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">`ucode`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">`trade_mode`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div><p>2、<strong>对于那些不是每次查询都会出现的条件，可以考虑创建单独的索引 例如：declare_status 它不是每次都出现在查询中，可以创建单字段索引</strong></p><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">ALTER</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> TABLE</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 表名 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">ADD</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> INDEX</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> `idx1`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">`ucode`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div><p>3、<strong>如果某些字段偶尔出现在查询中，并且数据量较大时使用这些字段可以提高查询效率，可以将这些字段添加到复合索引中</strong><strong>例如：</strong></p><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">ALTER</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> TABLE</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 表名 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">ADD</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> INDEX</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> `idx2`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">`ucode`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">`trade_mode`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">`declare_statu`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div><p>此时再次查询就会命中该索引 效率更高</p><h2 id="注意" tabindex="-1">注意 <a class="header-anchor" href="#注意" aria-label="Permalink to &quot;注意&quot;">​</a></h2><ul><li><p><strong>注意添加索引时的先后顺序，否则会导致无法命中最理想的索引</strong></p><p>如查询sql为：EXPLAIN SELECT * FROM <code>jk_order</code>WHERE <code>ucode</code>=&#39;2fa5t&#39;AND <code>status</code>=60 AND <code>deal_status</code>=30 AND <code>push_type</code>=30 ORDER BY <code>create_time</code>DESC</p><p>理论上idx3是最佳的索引</p><p><img src="'+n+'" alt="image-20240817143143775"></p><p>但实际中因为优先级较低 会导致命中idx1或idx2索引</p><p><img src="'+e+'" alt="image-20240817143418962"></p><p>这时如果调整顺序</p><p><img src="'+p+'" alt="image-20240817143516116"></p><p>​ 再次查询则正常命中</p><p><img src="'+h+'" alt="image-20240817143550782"></p><p>实际添加复合索引时 要综合考虑下再决定</p></li><li><p>查询时字段值的类型要和字段类型保持一致，否则可能会导致索引失效</p></li><li><p>复合索引要合理调整字段优先级，否则也会导致索引失效</p></li></ul><h2 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h2><blockquote><p>1、数据量较多时，复合索引更有效。 2、数据量较少时，全表扫描可能更快。 3、对于总是出现在查询中的字段，创建复合索引。 4、对于偶尔出现在查询中的字段，可以考虑创建单字段索引</p></blockquote>',32),d=[r];function E(o,g,c,y,_,m){return a(),i("div",null,d)}const F=s(k,[["render",E]]);export{u as __pageData,F as default};
